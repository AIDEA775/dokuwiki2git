#!/usr/bin/env python
# Copyright (c) 2011-2014 Heikki Hokkanen <hoxu at users.sf.net>
# License: AGPLv3
import argparse
import fnmatch
import logging
import json
import os
import subprocess
import sys
import time

logging.basicConfig(level = logging.DEBUG, format = '%(levelname)s - %(message)s')
log = logging.getLogger()

class Converter:
	def __init__(self):
		self.args = None # arguments from the command line
		self.dwdata = {} # setting data loaded from the dokuwiki
		self.users = {} # user data loaded from the dokuwiki
		self.changelog = [] # [date, ip, type, id, user, sum, extra]
		self.pagechanges = {} # { pagesubpath: [date, ip, type, id, user, sum, extra] }
		self.commands = [] # shell commands to run

	def create_git_repository(self):
		log.info('Creating git repository')
		origdir = os.getcwd()
		os.mkdir(self.args.outputdir)
		os.chdir(self.args.outputdir)
		# run all commands
		for c in self.commands:
			log.debug('CMD: %s' % c)
			ret = subprocess.call(c, shell=True)
			if ret != 0:
				raise RuntimeError('Command "%s" failed' % c)
		os.chdir(origdir)

	def read_attic(self):

		def get_source_file(subpath, timestamp):
			# try attic/ folder for each compression types
			filename = os.path.join(self.dwdata['conf']['olddir'].encode('UTF-8'), '%s.%s.txt' % (subpath, timestamp))
			if os.path.exists(filename): return filename
			filename = os.path.join(self.dwdata['conf']['olddir'].encode('UTF-8'), '%s.%s.txt.gz' % (subpath, timestamp))
			if os.path.exists(filename): return filename
			filename = os.path.join(self.dwdata['conf']['olddir'].encode('UTF-8'), '%s.%s.txt.bz2' % (subpath, timestamp))
			if os.path.exists(filename): return filename
			# try pages/ folder
			filename = os.path.join(self.dwdata['conf']['datadir'].encode('UTF-8'), '%s.txt' % subpath)
			if os.path.exists(filename) and str(int(os.path.getmtime(filename))) == timestamp: return filename
			# not exist, error out
			log.warn('Attic of page "%s" with timestamp "%s" does not exist, despite being in changelog, skipping' % (subpath, timestamp))
			return None

		def add_commit(timestamp, ip, type, id, user, message, extra):
			subpath = id.replace(':', '/')
			source_file = get_source_file(subpath, timestamp)
			if source_file is None: return
			# author (user <email>)
			email = ''
			if len(user) == 0:
				user = ip
			elif user in self.users:
				email = self.users[user]['email']
				user = self.users[user]['name']
			else:
				user = '%s@%s' % (user, self.args.domain)
			author = '%s <%s>' % (user, email)
			# message
			message = '%s: %s' % (subpath, message)
			# target_file
			target_file = os.path.join('pages', '%s.txt' % subpath)
			# build commands
			cmds = []
			if type in ('C', 'E', 'e', 'R'): # create, edit, minor edit, restore
				dirname = os.path.dirname(target_file)
				if len(dirname) > 0:
					cmds.append('mkdir -p %s' % self.shell_quote(dirname))
				if fnmatch.fnmatch(source_file, '*.txt'):
					cmds.append('cp -a %s %s' % (self.shell_quote(source_file), self.shell_quote(target_file)))
				elif fnmatch.fnmatch(source_file, '*.txt.gz'):
					cmds.append('gunzip -c %s > %s' % (self.shell_quote(source_file), self.shell_quote(target_file)))
				elif fnmatch.fnmatch(source_file, '*.txt.bz2'):
					cmds.append('bunzip2 -c %s > %s' % (self.shell_quote(source_file), self.shell_quote(target_file)))
				cmds.append('git add %s' % self.shell_quote(target_file))
			elif type == 'D': # delete
				cmds.append('git rm --quiet %s' % self.shell_quote(target_file))
			cmds.append('git commit --quiet --allow-empty --allow-empty-message --author=%s --date=%s -m %s' % (self.shell_quote(author), self.shell_quote(timestamp), self.shell_quote(message)))
			self.commands.extend(cmds)

		log.info('Reading attic')
		for (timestamp, ip, type, id, user, message, extra) in self.changelog:
			add_commit(timestamp, ip, type, id, user, message, extra)

	def check_attic(self):

		def check_page_entry(subpath, timestamp):
			id = subpath.replace('/', ':')
			if id in self.pagechanges:
				for c in self.pagechanges[id]:
					if timestamp == c[0] and id == c[3]:
						return
			log.warn('Attic contains "%s" timestamp %s, but is not referenced by changelog, skipping. Please report this!' % (id, timestamp))

		log.info('Checking attic')
		root = self.dwdata['conf']['olddir'].encode('UTF-8')
		for path, dirs, files in os.walk(root):
			for f in files:
				if fnmatch.fnmatch(f, '*.txt') or fnmatch.fnmatch(f, '*.txt.gz') or fnmatch.fnmatch(f, '*.txt.bz2'):
					fullpath = os.path.join(path, f)
					subpath = os.path.relpath(fullpath, root)
					if fnmatch.fnmatch(fullpath, '*.txt'):
						subpath, timestamp, txt = subpath.rsplit('.', 2)
					else:
						subpath, timestamp, txt, zip = subpath.rsplit('.', 3)
					check_page_entry(subpath, timestamp)

	def read_media(self):
		log.info('Reading media')
		for path, dirs, files in os.walk(self.dwdata['conf']['mediadir'].encode('UTF-8')):
			for f in files:
				fullfile = os.path.join(path, f)
				filename = os.path.join('media', os.path.relpath(fullfile, self.dwdata['conf']['mediadir'].encode('UTF-8')))
				dirname = os.path.dirname(filename)
				cmds = [
					'mkdir -p %s' % self.shell_quote(dirname),
					'cp %s %s' % (self.shell_quote(fullfile), self.shell_quote(filename)),
					'git add %s' % self.shell_quote(filename)
				]
				self.commands.extend(cmds)
		self.commands.append('git commit --quiet --allow-empty --author="dokuwiki2git <dokuwiki2git@hoxu.github.com>" -m "Import media files"')

	def read_meta(self):

		def read_meta_file(subpath, fullpath):
			if fnmatch.fnmatch(subpath, '_*'): return
			id = subpath.replace('/', ':')
			log.debug('Reading meta for page "%s"' % id)
			with open(fullpath, 'rb') as f:
				for line in f:
					line = line.rstrip('\n')
					if len(line) == 0: continue
					changeparts = line.split('\t')
					log.debug(changeparts)
					assert(len(changeparts) == 7)
					assert(changeparts[3] == id)
					assert(changeparts[2] in ('C', 'D', 'E', 'e', 'R')) # create, delete, edit, minor edit, restore
					self.changelog.append(changeparts)
					if id in self.pagechanges: self.pagechanges[id].append(changeparts)
					else: self.pagechanges[id] = [changeparts]

		log.info('Reading meta')
		root = self.dwdata['conf']['metadir'].encode('UTF-8')
		items = 0
		for path, dirs, files in os.walk(root):
			for f in files:
				if fnmatch.fnmatch(f, '*.changes'):
					fullpath = os.path.join(path, f)
					subpath = os.path.splitext(os.path.relpath(fullpath, root))[0]
					read_meta_file(subpath, fullpath)
					items += 1
		logs = len(self.changelog)
		log.info('%d changelog entries for %d pages found' % (logs, items))

	def read_pages(self):

		def get_pagepath_and_timestamp(filename):
			pagepath = os.path.relpath(filename, self.dwdata['conf']['datadir'].encode('UTF-8'))
			return pagepath.rsplit('.', 1)[0], str(int(os.path.getmtime(filename)))

		def last_changelog_entry(pagepath, timestamp):
			lasttimestamp = None
			lasttype = None
			pagepath = pagepath.replace('/', ':')
			if pagepath in self.pagechanges:
				c = self.pagechanges[pagepath][-1]
				lasttimestamp, lasttype = c[0], c[2]
			return lasttimestamp, lasttype

		log.info('Reading pages for possible external edits')

		# Check the pages directory for external edits not yet recorded in the meta
		pages = 0
		for path, dirs, files in os.walk(self.dwdata['conf']['datadir'].encode('UTF-8')):
			for f in files:
				if fnmatch.fnmatch(f, '*.txt'):
					filename = os.path.join(path, f)
					pagepath, timestamp = get_pagepath_and_timestamp(filename)
					lasttimestamp, lasttype = last_changelog_entry(pagepath, timestamp)
					if lasttimestamp is None or lasttimestamp < timestamp:
						type = 'C' if lasttype is None or lasttype == 'D' else 'E'
						changeparts = [timestamp, '127.0.0.1', type, pagepath, '', self.dwdata['lang']['external_edit'].encode('UTF-8'), '']
						log.debug(changeparts)
						self.changelog.append(changeparts)
						pages += 1
		log.info('%d newly edited pages found' % (pages))

	def read_user_data(self):
		log.info('Reading users.auth.php')
		users_file = self.dwdata['config_cascade']['plainauth.users']['default'].encode('UTF-8')
		with open(users_file, 'rb') as f:
			for line in f:
				if not line.startswith("#") and len(line) > 1:
					userparts = line.split(':')
					assert(len(userparts) == 5)
					log.debug(userparts)
					self.users[userparts[0]] = {'name' : userparts[2], 'email': userparts[3]}
		log.info('Read %d users' % len(self.users))

	def run(self, params):
		parser = argparse.ArgumentParser(
			prog='dokuwiki2git',
			description='''dokuwiki2git converts dokuwiki data directory into a git repository containing the wiki pages, with proper history. Thus, migration to git-backed wiki engines (eg. gollum) becomes easier.''')
		parser.add_argument('-o', '--output', dest='outputdir', default = 'gitdir', metavar='<output dir>', help='directory to create the git repo (default: %(default)s)')
		parser.add_argument('-u', '--users', dest='import_user', action='store_true', help='record the author of every change with real user name and email from dokuwiki database, instead of id@dokuwiki-domain')
		parser.add_argument('-e', '--external-edit', action='store_true', dest='external_edit', help='import external edits not recorded in meta .changes')
		parser.add_argument('-q', '--quiet', action='store_const', dest='verbose', const=0, default=1, help='show only warnings and errors')
		parser.add_argument('-v', '--verbose', action='store_const', dest='verbose', const=2, default=1, help='show debug messages')
		parser.add_argument('dwdir', metavar='<dokuwiki dir>', help='path to dokuwiki')
		parser.add_argument('domain', metavar='<dokuwiki domain>', nargs='?', default='dokuwiki.localhost', help='domain name (or IP) of the dokuwiki site, for better authorship tracing')

		# parse arguments
		self.args = args = parser.parse_args(params)
		log.setLevel((logging.WARN, logging.INFO, logging.DEBUG)[args.verbose])

		time_start = time.time()
		log.info('Import data from dokuwiki "%s" at domain "%s"' % (args.dwdir, args.domain))

		# check and load dokuwiki data
		try:
			self.dwdata = json.loads(subprocess.check_output('php dokuwiki.php %s' % self.shell_quote(args.dwdir), shell=True))
		except:
			log.error('Unable to read php scripts from the specified dokuwiki directory')
			sys.exit(1)
		# check output directory
		if os.path.exists(args.outputdir):
			log.error('There is already something at the output directory path "%s"' % args.outputdir)
			sys.exit(1)
		# read user Real Name and email from dokuwiki, if requested and available
		if self.args.import_user and self.dwdata['conf']['authtype'] == 'authplain':
			self.read_user_data()

		# collect history
		# go through meta/ *.changes to collect the change history
		# if "detect external edit" is set, also go through pages/ for latest version not recorded
		self.read_meta()
		if args.external_edit:
			self.read_pages()
		self.changelog.sort()
		
		# build commands
		self.commands.append('git init --quiet')
		# for each change history collected, find the corresponding history data file and build the import commands
		self.read_attic()
		# check the attic/ for data files not recorded in the change history
		self.check_attic()
		# import media additionally
		self.read_media()
		# add a note for importing
		self.commands.append('git commit --quiet --allow-empty --author="dokuwiki2git <dokuwiki2git@hoxu.github.com>" -m "Dokuwiki data imported by dokuwiki2git"')

		# start running the shell commands
		log.info('%d commands queued to be executed' % len(self.commands))
		self.create_git_repository()

		# success, calculate and show the time spent
		time_end = time.time()
		time_took = time_end - time_start
		log.info('Finished converting dokuwiki "%s" into a git repository "%s", took %.2f seconds' % (args.dwdir, self.args.outputdir, time_took))

	def shell_quote(self, str):
		return "'" + str.replace("'", "'\\''") + "'"

if __name__ == '__main__':
	c = Converter()
	c.run(sys.argv[1:])
